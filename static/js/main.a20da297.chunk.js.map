{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["App","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","modules","toolbar","header","list","script","indent","direction","size","color","background","font","align","handleChange","value","setState","quill_text","document","getElementById","innerHTML","handleEditorChange","e","tiny_MCE_text","target","getContent","handleCKEditorChange","editor","ck_text","getData","console","log","state","react_default","a","createElement","className","ckeditor_default","ClassicEditor","data","config","extraPlugins","Base64UploadAdapterPlugin","removePlugins","onChange","id","Component","plugins","get","createUploadAdapter","loader","UploadAdapter","t","_this3","Promise","resolve","reject","reader","window","FileReader","onload","default","result","onerror","error","onabort","readAsDataURL","file","abort","Boolean","location","hostname","match","ReactDOM","render","src_App_0","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"oPAaMA,cACJ,SAAAA,EAAYC,GAAO,IAAAC,EAAA,OAAAC,OAAAC,EAAA,EAAAD,CAAAE,KAAAL,IACjBE,EAAAC,OAAAG,EAAA,EAAAH,CAAAE,KAAAF,OAAAI,EAAA,EAAAJ,CAAAH,GAAAQ,KAAAH,KAAMJ,KAQRQ,QAAU,CACRC,QAAS,CACP,CAAC,OAAQ,SAAU,YAAa,UAChC,CAAC,aAAc,aAAc,SAE7B,CAAC,CAAEC,OAAU,GAAK,CAAEA,OAAU,IAC9B,CAAC,CAAEC,KAAQ,WAAY,CAAEA,KAAQ,WACjC,CAAC,CAAEC,OAAU,OAAQ,CAAEA,OAAU,UACjC,CAAC,CAAEC,OAAU,MAAO,CAAEA,OAAU,OAChC,CAAC,CAAEC,UAAa,QAEhB,CAAC,CAAEC,KAAQ,CAAC,SAAS,EAAO,QAAS,UACrC,CAAC,CAAEL,OAAU,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,GAAG,KAEhC,CAAC,CAAEM,MAAS,IAAM,CAAEC,WAAc,KAClC,CAAC,CAAEC,KAAQ,KACX,CAAC,CAAEC,MAAS,KAEZ,CAAC,WA3BclB,EA+BnBmB,aAAe,SAACC,GACdpB,EAAKqB,SAAS,CAAEC,WAAYF,IAC5BG,SAASC,eAAe,QAAQC,UAAYL,GAjC3BpB,EAoCnB0B,mBAAqB,SAACC,GACpB3B,EAAKqB,SAAS,CAAEO,cAAeD,EAAEE,OAAOC,gBArCvB9B,EAwCnB+B,qBAAuB,SAACJ,EAAGK,GACzBhC,EAAKqB,SAAS,CAAEY,QAASD,EAAOE,YAChCC,QAAQC,IAAIJ,EAAOE,WACnBX,SAASC,eAAe,QAAQC,UAAYO,EAAOE,WAzCnDlC,EAAKqC,MAAQ,CACXf,WAAY,qDACZM,cAAe,uDACfK,QAAS,IALMjC,wEA+CjB,OACEsC,EAAAC,EAAAC,cAAA,OAAKC,UAAU,OAqBbH,EAAAC,EAAAC,cAAA,OAAKC,UAAU,YACbH,EAAAC,EAAAC,cAACE,EAAAH,EAAD,CACEP,OAASW,IACTC,KAAMzC,KAAKkC,MAAMJ,QACjBY,OAAQ,CAGNC,aAAc,CAAEC,GAChBC,cAAe,CAAE,aAAc,aAAc,QAAS,cACtDxC,QAAS,CACP,UACA,IACA,YAGA,OACA,eACA,eACA,gBAMJyC,SAAU9C,KAAK4B,wBAGnBO,EAAAC,EAAAC,cAAA,OAAKU,GAAG,QACL/C,KAAKkC,MAAMJ,iBAlGJkB,aA+MlB,SAASJ,EAA2Bf,GAClCA,EAAOoB,QAAQC,IAAK,kBAAmBC,oBAAsB,SAAEC,GAAF,OAAc,IAAIC,EAAeD,QAG1FC,aACL,SAAAA,EAAaD,EAAQE,GAAKxD,OAAAC,EAAA,EAAAD,CAAAE,KAAAqD,GACzBrD,KAAKoD,OAASA,uDAGN,IAAAG,EAAAvD,KACR,OAAO,IAAIwD,QAAS,SAAEC,EAASC,GAC9B,IAAMC,EAASJ,EAAKI,OAAS,IAAIC,OAAOC,WAExCF,EAAOG,OAAS,WACfL,EAAS,CAAEM,QAASJ,EAAOK,UAG5BL,EAAOM,QAAU,SAAUC,GAC1BR,EAAQQ,IAGTP,EAAOQ,QAAU,WAChBT,KAGDC,EAAOS,cAAeb,EAAKH,OAAOiB,wCAK9BrE,KAAK2D,QACT3D,KAAK2D,OAAOW,iBAKA3E,ICpPK4E,QACW,cAA7BX,OAAOY,SAASC,UAEe,UAA7Bb,OAAOY,SAASC,UAEhBb,OAAOY,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAOzC,EAAAC,EAAAC,cAACwC,EAAD,MAASzD,SAASC,eAAe,SD2H3C,kBAAmByD,WACrBA,UAAUC,cAAcC,MAAMC,KAAK,SAAAC,GACjCA,EAAaC","file":"static/js/main.a20da297.chunk.js","sourcesContent":["import React, { Component } from 'react';\nimport './App.css';\n\nimport * as ReactQuill from 'react-quill';\nimport 'react-quill/dist/quill.snow.css';\n\nimport { Editor } from '@tinymce/tinymce-react';\n\nimport CKEditor from '@ckeditor/ckeditor5-react';\nimport ClassicEditor from '@ckeditor/ckeditor5-build-classic';\n// import Essentials from '@ckeditor/ckeditor5-essentials/src/essentials';\n// import Alignment from '@ckeditor/ckeditor5-alignment/src/alignment';\n\nclass App extends Component {\n  constructor(props) {\n    super(props)\n    this.state = { \n      quill_text: '<p>This is the initial content of quill editor</p>',\n      tiny_MCE_text: '<p>This is the initial content of tinyMCE editor</p>',\n      ck_text: ''\n    }\n  }\n\n  modules = {\n    toolbar: [\n      ['bold', 'italic', 'underline', 'strike'],        // toggled buttons\n      ['blockquote', 'code-block', 'image'],\n\n      [{ 'header': 1 }, { 'header': 2 }],               // custom button values\n      [{ 'list': 'ordered'}, { 'list': 'bullet' }],\n      [{ 'script': 'sub'}, { 'script': 'super' }],      // superscript/subscript\n      [{ 'indent': '-1'}, { 'indent': '+1' }],          // outdent/indent\n      [{ 'direction': 'rtl' }],                         // text direction\n\n      [{ 'size': ['small', false, 'large', 'huge'] }],  // custom dropdown\n      [{ 'header': [1, 2, 3, 4, 5, 6, false] }],\n\n      [{ 'color': [] }, { 'background': [] }],          // dropdown with defaults from theme\n      [{ 'font': [] }],\n      [{ 'align': [] }],\n\n      ['clean'] \n    ],\n  }\n \n  handleChange = (value) => {\n    this.setState({ quill_text: value })\n    document.getElementById(\"view\").innerHTML = value\n  }\n\n  handleEditorChange = (e) => {\n    this.setState({ tiny_MCE_text: e.target.getContent() })\n  }\n\n  handleCKEditorChange = (e, editor) => {\n    this.setState({ ck_text: editor.getData() })\n    console.log(editor.getData())\n    document.getElementById(\"view\").innerHTML = editor.getData()\n  }\n\n  render() {\n    return (\n      <div className=\"App\">\n        {/* <div className=\"App-wrap\">\n          <ReactQuill \n            value={this.state.quill_text}\n            onChange={this.handleChange}\n            modules={this.modules}\n            imageHandler={this.imageHandler}\n          />\n        </div>\n        <div id=\"view\" className=\"App-wrap\">\n          {this.state.quill_text}\n        </div> */}\n        {/* <Editor\n          initialValue={this.state.tiny_MCE_text}\n          init={{\n            plugins: 'link image code',\n            toolbar: 'undo redo | bold italic | alignleft aligncenter alignright | code | link image',\n          }}\n          onChange={this.handleEditorChange}\n        />\n        {this.state.tiny_MCE_text} */}\n        <div className=\"App-wrap\">\n          <CKEditor\n            editor={ ClassicEditor }\n            data={this.state.ck_text}\n            config={{\n              // plugins: [ Essentials, Alignment ],\n              // toolbar: [ 'alignment' ]\n              extraPlugins: [ Base64UploadAdapterPlugin ],\n              removePlugins: [ 'MediaEmbed', 'ImageStyle', 'Table', \"BlockQuote\" ],\n              toolbar: [\n                'heading',\n                '|',\n                'alignment',\n                // 'bold',\n                // 'italic',\n                'link',\n                'bulletedList',\n                'numberedList',\n                'imageUpload',\n                // 'blockQuote',\n                // 'undo',\n                // 'redo'\n              ]\n            }}\n            onChange={this.handleCKEditorChange}\n          />\n        </div>\n        <div id=\"view\">\n          {this.state.ck_text}\n        </div>\n      </div>\n    );\n  }\n}\n\nclass MyUploadAdapter {\n  constructor( loader ) {\n      // The file loader instance to use during the upload.\n      this.loader = loader;\n  }\n\n  // Starts the upload process.\n  upload() {\n      return new Promise( ( resolve, reject ) => {\n          this._initRequest();\n          this._initListeners( resolve, reject );\n          this._sendRequest();\n      } );\n  }\n\n  // Aborts the upload process.\n  abort() {\n      if ( this.xhr ) {\n          this.xhr.abort();\n      }\n  }\n\n  // Initializes the XMLHttpRequest object using the URL passed to the constructor.\n  _initRequest() {\n      const xhr = this.xhr = new XMLHttpRequest();\n\n      // Note that your request may look different. It is up to you and your editor\n      // integration to choose the right communication channel. This example uses\n      // a POST request with JSON as a data structure but your configuration\n      // could be different.\n      xhr.open( 'POST', 'http://example.com/image/upload/path', true );\n      xhr.responseType = 'json';\n  }\n\n  // Initializes XMLHttpRequest listeners.\n  _initListeners( resolve, reject ) {\n      const xhr = this.xhr;\n      const loader = this.loader;\n      const genericErrorText = 'Couldn\\'t upload file:' + ` ${ loader.file.name }.`;\n\n      xhr.addEventListener( 'error', () => reject( genericErrorText ) );\n      xhr.addEventListener( 'abort', () => reject() );\n      xhr.addEventListener( 'load', () => {\n          const response = xhr.response;\n\n          // This example assumes the XHR server's \"response\" object will come with\n          // an \"error\" which has its own \"message\" that can be passed to reject()\n          // in the upload promise.\n          //\n          // Your integration may handle upload errors in a different way so make sure\n          // it is done properly. The reject() function must be called when the upload fails.\n          if ( !response || response.error ) {\n              return reject( response && response.error ? response.error.message : genericErrorText );\n          }\n\n          // If the upload is successful, resolve the upload promise with an object containing\n          // at least the \"default\" URL, pointing to the image on the server.\n          // This URL will be used to display the image in the content. Learn more in the\n          // UploadAdapter#upload documentation.\n          resolve( {\n              default: response.url\n          } );\n      } );\n\n      // Upload progress when it is supported. The file loader has the #uploadTotal and #uploaded\n      // properties which are used e.g. to display the upload progress bar in the editor\n      // user interface.\n      if ( xhr.upload ) {\n          xhr.upload.addEventListener( 'progress', evt => {\n              if ( evt.lengthComputable ) {\n                  loader.uploadTotal = evt.total;\n                  loader.uploaded = evt.loaded;\n              }\n          } );\n      }\n  }\n\n  // Prepares the data and sends the request.\n  _sendRequest() {\n      // Prepare the form data.\n      const data = new FormData();\n      data.append( 'upload', this.loader.file );\n\n      // Important note: This is the right place to implement security mechanisms\n      // like authentication and CSRF protection. For instance, you can use\n      // XMLHttpRequest.setRequestHeader() to set the request headers containing\n      // the CSRF token generated earlier by your application.\n\n      // Send the request.\n      this.xhr.send( data );\n  }\n}\n\n// ...\n\nfunction MyCustomUploadAdapterPlugin( editor ) {\n  editor.plugins.get( 'FileRepository' ).createUploadAdapter = ( loader ) => {\n      // Configure the URL to the upload script in your back-end here!\n      return new MyUploadAdapter( loader );\n  };\n}\n\nfunction Base64UploadAdapterPlugin( editor ) {\n  editor.plugins.get( 'FileRepository' ).createUploadAdapter = ( loader ) => new UploadAdapter( loader );\n}\n\nclass UploadAdapter {\n\tconstructor( loader, t ) {\n\t\tthis.loader = loader;\n  }\n  \n\tupload() {\n\t\treturn new Promise( ( resolve, reject ) => {\n\t\t\tconst reader = this.reader = new window.FileReader();\n\n\t\t\treader.onload = function() {\n\t\t\t\tresolve( { default: reader.result } );\n\t\t\t};\n\n\t\t\treader.onerror = function( error ) {\n\t\t\t\treject( error );\n\t\t\t};\n\n\t\t\treader.onabort = function() {\n\t\t\t\treject();\n\t\t\t};\n\n\t\t\treader.readAsDataURL( this.loader.file );\n\t\t} );\n\t}\n\n\tabort() {\n\t\tif ( this.reader ) {\n\t\t\tthis.reader.abort();\n\t\t}\n\t}\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}